pragma cashscript ^0.10.0;

/// <summary>
///     Create a token mining contract that follows a half-life algorithm
/// </summary>
/// <param name="fund">The receiving fund</param>
/// <param name="tokenSupply">The token's full supply</param>
/// <param name="genesisBlockHeight">The genesis height, corresponding to Bitcoin's height, this token starts on</param>
/// <param name="genesisBlockReward">The initial reward released</param>
/// <param name="halvingLength">The number of blocks between each halving</param>
contract TokenMining(
    pubkey fund,
    // int tokenSupply,
    // int genesisBlockHeight,
    // int genesisBlockReward,
    // int halvingLength,
) {
    /// <summary>
    ///     Mint the NFT state object BEFORE the genesis block
    /// </summary>
    /// <param name="signature">Fund's signature</param>
    /// <param name="blockHeight">Current block height</param>
    /// <inputs>
    ///     <i0>The token's UTXO</i0>
    /// </inputs>
    /// <outputs>
    ///     <o0>Return i0 back to contract</o0>
    ///     <o1>The initialized state object</o1>
    /// </outputs>
    // function mintGenesis() {
    //     require(within(halvingLength, 1, 500000000));

    //     // inputs
    //     require(tx.inputs.length == 1);
    //     require(tx.inputs[0].tokenAmount == tokenSupply); // ensure we start w/ the full supply

    //     // outputs
    //     require(tx.outputs.length == 2);
    //     require(tx.outputs[0].tokenAmount == tokenSupply);
    //     require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    //     require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
    //     require(tx.outputs[1].nftCommitment == ((bytes8(genesisBlockHeight) + bytes8(genesisBlockHeight) + bytes8(genesisBlockReward))));
    // }    

    /// <summary>
    ///     Release the tokens up to the current block height or halving event which ever comes first
    /// </summary>
    /// <notes>
    ///     If the halving event occurred between last release and current block then call this function multiple times to release all available funds
    /// </notes>
    /// <param name="signature">Fund's signature</param>
    /// <param name="blockHeight">Current block height</param>
    /// <inputs>
    ///     <i0>The token's UTXO</i0>
    ///     <i1>The state object</i1>
    /// </inputs>
    /// <outputs>
    ///     <o0>Send tokens to fund</o0>
    ///     <o1>Return i0 back to contract unless EOL</o1>
    ///     <o2>The initialized state object unless EOL</o2>
    /// </outputs>
    function releaseRewards(int blockHeight) {
        require(tx.time >= blockHeight); // ensure blockHeight is at most the current height

        // inputs
        require(tx.inputs.length == 2);
        require(tx.inputs[0].outpointTransactionHash == tx.inputs[1].outpointTransactionHash);

        // outputs
        bytes25 recipientLockingBytecode = new LockingBytecodeP2PKH(hash160(fund));
        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);

        // get state
        bytes state = tx.inputs[1].nftCommitment;
        bytes releaseHeight_state, bytes others = state.split(8);
        bytes halvingHeight_state, bytes reward_state = others.split(8);
        bytes reward_state, bytes halvingLength_state = 
        
        int releaseHeight = int(releaseHeight_state);
        int halvingHeight = int(halvingHeight_state);
        int reward = int(reward_state);

        require(within(halvingLength, 1, 500000000));
        // ensure blocks to release
        require(tx.time >= releaseHeight);
        require(blockHeight >= releaseHeight);

        // declare next state
        int releaseHeight_next = blockHeight;
        int halvingHeight_next = halvingHeight;
        int reward_next = reward;

        // logic
        int passedBlocksSinceRelease = blockHeight - releaseHeight;
        int passedBlocksSinceHalving = blockHeight - halvingHeight;
        int releaseAmount = passedBlocksSinceRelease * reward;

        // halving event; release height will stop at halving height
        if (passedBlocksSinceHalving >= halvingLength) {
            releaseHeight_next = releaseHeight + halvingLength;
            halvingHeight_next = releaseHeight_next;
            reward_next = reward / 2;

            passedBlocksSinceRelease = releaseHeight_next - releaseHeight;
            releaseAmount = passedBlocksSinceRelease * reward;
        }

        // calc change
        int tokenAmount = tx.inputs[0].tokenAmount;
        int changeAmount = tokenAmount - releaseAmount;

        if (changeAmount <= reward) { // EOL
            require(tx.outputs.length == 1);
        } else { // normal release
            require(tx.outputs.length == 3);

            // Check that the outputs send the correct amounts
            require(tx.outputs[0].tokenAmount == releaseAmount);
            require(tx.outputs[1].tokenAmount == changeAmount);

            // Send the change value back to the same smart contract locking bytecode
            require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
            // Send the nft commitment to contract locking bytecode
            require(tx.outputs[2].lockingBytecode == tx.inputs[0].lockingBytecode);

            // Update the block height of the previous pledge, kept in the NFT commitment
            require(tx.outputs[2].nftCommitment == bytes8(releaseHeight_next) + bytes8(halvingHeight_next) + bytes8(reward_next));
        }
    }

    /// <summary>
    ///     Combine additional fund inputs (Bitcoin and/or token) w/ the main input
    /// </summary>
    /// <notes>
    ///     If the halving event occurred between last release and current block then call this function multiple times to release all available funds
    /// </notes>
    /// <param name="signature">Fund's signature</param>
    /// <inputs>
    ///     <i0>The token's UTXO</i0>
    ///     <i1>The state object</i1>
    ///     <i2>Addditional funds to combine</i2>
    /// </inputs>
    /// <outputs>
    ///     <o1>Return i0 + i2 back to contract</o1>
    ///     <o2>The initialized state object</o2>
    /// </outputs>
    function combineFunds() {
        // inputs
        require(tx.inputs.length == 3);
        require(tx.inputs[0].outpointTransactionHash == tx.inputs[1].outpointTransactionHash);

        // outputs
        require(tx.outputs.length == 2);

        int newTokenAmount = tx.inputs[0].tokenAmount + tx.inputs[2].tokenAmount;
        require(tx.outputs[0].tokenAmount == newTokenAmount);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        
        require(tx.outputs[1].nftCommitment == tx.inputs[1].nftCommitment);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
    }
}

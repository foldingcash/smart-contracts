pragma cashscript ^0.10.0;

contract TokenMining_Mint(
    pubkey fund,
) {
    function mintToken(int tokenAmount) {
        // validate parameters
        require(tokenAmount > 0);

        // validate inputs
        require(tx.inputs.length == 1);
        require(tx.inputs[0].lockingBytecode == new LockingBytecodeP2PKH(hash160(fund)));
        require(tx.inputs[0].tokenCategory == 0x);

        // validate outputs
        require(tx.outputs.length == 1);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].outpointTransactionHash);
        require(tx.outputs[0].tokenAmount == tokenAmount);
        require(tx.outputs[0].nftCommitment == 0x);
    }

    function mintState(pubkey nextContract, int tokenLockAmount, int initialBlockHeight, int initialRewardAmount) {
        // parameter validation
        require(tokenLockAmount > 0);
        require(initialBlockHeight >= 0);
        require(initialRewardAmount > 0);

        bytes25 fundLockingBytecode = new LockingBytecodeP2PKH(hash160(fund));

        // verify inputs
        require(tx.inputs.length == 1);
        require(tx.inputs[0].lockingBytecode == fundLockingBytecode);
        require(tx.inputs[0].tokenCategory != 0x);
        require(tx.inputs[0].tokenAmount >= tokenLockAmount);
        require(tx.inputs[0].nftCommitment == 0x);
        
        // verify outputs
        require(tx.outputs.length == 3);        

        bytes25 nextContractLockingBytecode = new LockingBytecodeP2PKH(hash160(nextContract));
        
        // verify token output
        require(tx.outputs[0].lockingBytecode == nextContractLockingBytecode);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount - tokenLockAmount);

        // verify state output
        require(tx.outputs[1].lockingBytecode == nextContractLockingBytecode);
        require(tx.outputs[1].tokenCategory == (0x00 + tx.inputs[0].outpointTransactionHash));
        require(tx.outputs[1].nftCommitment == bytes8(initialBlockHeight) + bytes8(initialBlockHeight) + bytes8(initialRewardAmount));

        // verify change output
        require(tx.outputs[2].lockingBytecode == fundLockingBytecode);
        require(tx.outputs[2].nftCommitment == 0x);

        // verify token change output
        int tokenChange = max(tx.inputs[0].tokenAmount - tokenLockAmount, 0);
        if(tokenChange > 0) {
            require(tx.outputs[2].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[2].tokenAmount == tokenChange);
        } else {
            require(tx.outputs[2].tokenCategory == 0x);
        }
    }
}
